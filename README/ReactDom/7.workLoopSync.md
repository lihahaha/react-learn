## workLoopSync
通过workInProgress Fiber 树中的 rootFiber 构建完成，接下来要构建它的子级 fiber 对象了。
这个子级 fiber 对象就是 render 方法的第一个参数，它在代码走到 workLoopSync 方法时开始被构建。
workLoopSync 就是开启一个循环，以同步的方式开始构建 fiber 对象
1. workLoopSync构建 rootFiber 对象的所有子级 fiber 对象
```
function workLoopSync() {
  // workInProgress 是一个 fiber 对象
  // 它的值不为 null 意味着该 fiber 对象上仍然有更新要执行
  // while 方法支撑 render 阶段 所有 fiber 节点的构建
  while (workInProgress !== null) {
    workInProgress = performUnitOfWork(workInProgress);
  }
}
```
2. performUnitOfWork
- beginWork：从父到子，构建子级节点 fiber 对象
- completeUnitOfWork：从子到父，构建其余节点的 fiber 对象
在16中使用模拟递归的方式完成fiber节点的构建，就是beginWork从父到子，completeUnitOfWork相反
```
// 不断构建 fiber 对象的子级所对应的fiber对象
function performUnitOfWork(unitOfWork: Fiber): Fiber | null {
  // unitOfWork => workInProgress Fiber 树中的 rootFiber
  // current => currentFiber 树中的 rootFiber
  const current = unitOfWork.alternate;

  startWorkTimer(unitOfWork);
  setCurrentDebugFiberInDEV(unitOfWork); // 开发环境的忽略

  let next; // 存储下一个要构建的子级 Fiber 对象
  // 初始渲染是false
  if (enableProfilerTimer && (unitOfWork.mode & ProfileMode) !== NoMode) {
    startProfilerTimer(unitOfWork);
    next = beginWork(current, unitOfWork, renderExpirationTime);
    stopProfilerTimerIfRunningAndRecordDelta(unitOfWork, true);
  } else {
    // beginWork: 从父到子, 构建 Fiber 节点对象
    // 返回值 next 为当前节点的子节点
    next = beginWork(current, unitOfWork, renderExpirationTime); // 从父到子，构建子级节点 fiber 对象
  }

  resetCurrentDebugFiberInDEV(); // 开发环境的忽略
  // 为旧的 props 属性赋值
  // 此次更新后 pendingProps 变为 memoizedProps
  unitOfWork.memoizedProps = unitOfWork.pendingProps;
  // 如果子节点不存在说明当前节点向下遍历子节点已经到底了
  // 继续向上返回 遇到兄弟节点 构建兄弟节点的子 Fiber 对象 直到返回到根 Fiber 对象
  if (next === null) {
    // 从子到父, 构建其余节点 Fiber 对象
    next = completeUnitOfWork(unitOfWork);
  }

  ReactCurrentOwner.current = null;
  return next;
}
```
3. 