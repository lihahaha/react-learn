## ReactDom.render
1. 创建更新方式
- ReactDom.render
- setState
- forceUpdate

### Render
- 创建ReactRoot
- 创建FiberRoot和RootFiber
- 创建更新
- 进入更新调度阶段

### 代码
1. render函数
```
// 传入参数：reactElement，挂载Dom节点，回调函数渲染结束后调用
export function render(
  element: React$Element<any>,
  container: Container,
  callback: ?Function,
) {
  console.log('%crender', 'font-size:14px;color:green;');
  console.log(element, container, callback);
  return legacyRenderSubtreeIntoContainer(
    null,
    element,
    container,
    false, // 服务端渲染时时候是否复用dom节点，与客户端渲染的区别
    callback,
  );
}
```
2. legacyRenderSubtreeIntoContainer
```
function legacyRenderSubtreeIntoContainer(
  parentComponent: ?React$Component<any, any>, // null
  children: ReactNodeList, // 
  container: Container,
  forceHydrate: boolean,
  callback: ?Function,
) {
  let root: RootType = (container._reactRootContainer: any);
  let fiberRoot;
  if (!root) {
    // Initial mount
    root = container._reactRootContainer = legacyCreateRootFromDOMContainer(
      container,
      forceHydrate,
    );
    fiberRoot = root._internalRoot;
    if (typeof callback === 'function') {
      const originalCallback = callback;
      callback = function() {
        const instance = getPublicRootInstance(fiberRoot);
        originalCallback.call(instance);
      };
    }
    // Initial mount should not be batched.
    unbatchedUpdates(() => {
      updateContainer(children, fiberRoot, parentComponent, callback);
    });
  } else {
    fiberRoot = root._internalRoot;
    if (typeof callback === 'function') {
      const originalCallback = callback;
      callback = function() {
        const instance = getPublicRootInstance(fiberRoot);
        originalCallback.call(instance);
      };
    }
    // Update
    updateContainer(children, fiberRoot, parentComponent, callback);
  }
  return getPublicRootInstance(fiberRoot);
}
```
3. legacyCreateRootFromDOMContainer 创建ReactRoot
```
function legacyCreateRootFromDOMContainer(
  container: Container,
  forceHydrate: boolean, // false, hydrate传过来是true，是否需要调和子节点，服务端服用节点，节省性能
): RootType {
  
  const shouldHydrate =
    forceHydrate || shouldHydrateDueToLegacyHeuristic(container); // false
  // First clear any existing content.
  // 删除所有子节点
  if (!shouldHydrate) {
    let warned = false;
    let rootSibling;
    // 循环操作删除所有子节点
    while ((rootSibling = container.lastChild)) {
      container.removeChild(rootSibling);
    }
  }
  // 创建ReactRoot
  return createLegacyRoot(
    container,
    shouldHydrate
      ? {
          hydrate: true,
        }
      : undefined,
  );
}
```
最后创建出来的ReactRoot：
![ReactRoot](./image/legacyRenderSubtree.png)